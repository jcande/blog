Title: Programming with Dominoes
Date: 2022-03-04 14:47
Category: Automated Mosaic Construction
Tags: programming; esoteric; compilers; interpreters; graphics
Slug: wang-tiles
Authors: Jared Candelaria
TwitterName: @jsc29a
Summary: A web-based visualizer and toolchain for Wang tiles.
Status: published

To play around with graphics and wasm I implemented a renderer for a neat computer known as [wang tiles](https://en.wikipedia.org/wiki/Wang_tile). The project consists of a canvas-based tile visualizer, an interpreter that computes using tiles, and a W-Machine-to-Tile compiler to generate the tile sets. The renderer is fed visual data generated by the interpreter which is executing a program compiled from w-machine. Everything is written in rust and compiles to wasm. This article will give implementation details of the interpreter and renderer while providing some commentary about the state of wasm on rust. Of course you can simply play with the visualizer to generate pictures.

<center>
[![Hello domino world]({filename}/images/domino_default.png)]({filename}/data/domino/parlor.html)
</center>

If you're eager to program the machine, skip to [this section](#try-it-out). The [full source code](https://github.com/jcande/bones/) is also available.

[TOC]

# Dominoes are Programmable
Dominoes, those little rectangular tiles whose ends must match, are probably more powerful than you realize. But instead of those dominoes we'll be talking about wang tiles. You can get wang tiles from simple dominoes, just extend the pattern on the domino to include an east/west component as well as the original north/south component. This is the framework we'll be using to simulate a turing machine. When you dig into exactly how this is accomplished the real magic is in the matching and having two independent axes whereby you can pass data between.

Before digging in, we'll need to flesh out what exactly is meant by programmable. Abstractly, it means that these tiles are Turing-complete. <s>Practically</s> Concretely, we're trying to simulate the execution of a virtual machine somehow with these tiles. Before we can simulate some abstract machine, we need to create a mapping of the abstract machine state into the tile machine state. This step is where most of the fun comes in because we're taking a solid block of marble and chipping away at it until the abstract machine pops out. When we're satisfied with how to represent the abstract machine state with our components, usually creating the state transitions to "execute" the abstract machine are trivial.

# W-Machine as a Bundle of Tiles
With the problem roughly outlined, let's choose a particular abstract machine called [the W-Machine](https://en.wikipedia.org/wiki/Wang_B-machine). I've written about this simple Turing-machine before in the context of [tag systems]({filename}/tag.md#b-machines). The pros are that it is simple and each execution step does very little, which is convenient for understanding at this level. The cons are that it is essentially 1-bit brainfuck but with more traditional branching. Ok so there are no cons.

The representation I settled on was to have each tile represent a single bit on the infinite tape. The north pip holds the value of the bit during the incoming transition and the southern pip is the outgoing value. For the most part... The head gets a special encoding, but it must also include the incoming and outgoing bit of the given cell. East/West pips are only used to differentiate "border" tiles from the void, and to transition the head left and right. The code is more clear and for those that care a good start is [at the entry to the compiler](https://github.com/jcande/bones/blob/6e72f39e92a99b8ff60047e19ead446434e892ac/src/tessera.rs#L400).

This means that the set of all tiles corresponds in some sense to a tile machine language. A particular subset of tiles given an initial seed row (i.e., starting state) corresponds to a particular program. The implemented compiler is one mechanism for selecting a particular subset of tiles with certain properties, such as adhering to w-machine semantics given a specific representation. Now we obviously constructed this subset but thinking in terms of searches is useful for having to actually interpret these tile programs.

# Tiles as a Mosaic
Given our tile machine is completely specified at some instant by a row of tiles, and each row determines the subsequent row, we can track the execution state of the machine as a series of rows. If we plot these rows we get a nice visual representation of the tile machine's execution of a given program. And you know, that's pretty neat.

## Try it out
You can zoom in and out (on desktop; sorry mobile), click-and-drag to scroll the plane, as well as change the colors. The mosaic source and color parameters are sharable so you can link people to a pretty wallpaper directly. Not only is this a thoughtful gift but it will literally warm their heart as their computer heats up rendering each lovingly curated tile. I'm partial to [this colorscheme]({filename}/data/domino/parlor.html?palette_add=8&palette_mul=8) and imagine others will be too.

<p>
<form target="_blank" action="https://calabi-yau.space/blog/data/domino/parlor.html">
    <label for="source_code">W-Machine Source Input:</label><br />
    <div>
        <textarea name="src" id="source_code" rows="16" cols="36">
top:
->->->+>->+>+>->    /* h */
+>->+>->->+>+>->    /* e */
->->+>+>->+>+>->    /* l */
->->+>+>->+>+>->    /* l */
+>+>+>+>->+>+>->    /* o */
->->+>+>->+>->->    /* , */
->->->->->+>->->    /*   */
+>+>+>->+>+>+>->    /* w */
+>+>+>+>->+>+>->    /* o */
->+>->->+>+>+>->    /* r */
->->+>+>->+>+>->    /* l */
->->+>->->+>+>->    /* d */
->+>->+>->->->->    /* \n */
jmp top, top
        </textarea>
    </div>
    <input type="submit" value="View Mosaic">
</form>
</p>
### W-Machine Semantics
#### Tape Movement
<b>&lt;</b>

Move the head left one bit.

<b>&gt;</b>

Move the head right one bit.

#### Memory Access
<b>+</b>

Set the bit under the head.

<b>-</b>

Clear the bit under the head.

#### Control Flow
<i>label</i>

Create a label named <i>label</i>; used as a <b>jmp</b> destination.

<b>jmp</b> <i>TrueLabel</i>

Test the bit under the head, jmp to <i>TrueLabel</i> if set or fallthrough if clear.

<b>jmp</b> <i>TrueLabel</i><b>,</b> <i>FalseLabel</i>

Test the bit under the head, jmp to <i>FalseLabel</i> if clear.

#### Input/Output
<b>,</b>

Read a single bit from the environment and preserve it under the head.

<b>.</b>

Write a single bit to the environment taken from under the head.

NOTE These are unimplemented in the visual (wasm) code. But if you run this as a standalone executable it'll use stdin/stdout.

# Rule 110 as a Mosaic
The tile machine is pretty general. In fact, we can simulate [rule 110](https://en.wikipedia.org/wiki/Rule_110) with just a few tiles.

<center>
[![Rule 110 with wang tiles]({filename}/images/domino_rule110.png)]({filename}/data/domino/rule110.html)
</center>

The tile-set was taken from [Hao](https://esolangs.org/wiki/Hao).


# C -> W-Machine
A few years back I [implemented a backend targetting w-machine](https://github.com/shinh/elvm/blob/master/target/wm.c) for the wonderful [Esoteric Language Virtual Machine (elvm) project](https://github.com/shinh/elvm/). This means, in a certain sense, you can write programs in C and execute them with tiles. Something to consider for your shower renovation.

# Conclusion
I like writing rust. Debugging the wasm target, however, was not fun. It turns out there is really no debugging and reminded me of writing firmware for some really strange hardware. I'm confident this situation will improve with time.

This was my first time doing anything web-related and it was a lot to take in. I am likely doing a lot of very strange things but that's life.

The performance could be better.

Overall, I am satisfied. I think the visualizer looks good and it was fun threading all of the components together.
